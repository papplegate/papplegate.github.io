Title: A Python hunts the Wumpus
Date: 2024-11-12
Category: reimplementation

I recently [rewrote](https://github.com/papplegate/wumpus) the game _Hunt the Wumpus_ in Python.  In _Hunt the Wumpus_, you play a hunter who seeks to kill a creature called the Wumpus with your arrows.  Moving from room to room within a cave system, you look for traces of the Wumpus and avoid pits and super bats.  You win if you shoot the Wumpus with an arrow; you lose if you fall victim to the Wumpus or one of the hazards.

_Hunt the Wumpus_ comes to us from the early 1970s, an era when games were typed in from magazines or sent in the mail on cassettes.  The original code is given in a book called _What to Do After You Hit Return: A Computer Games Book from People's Computer Company_ (1977) and is written in Hewlett-Packard 2000F BASIC.  The game has been reimplemented and improved upon repeatedly, both [soon after its initial publication](https://archive.org/details/Super-Wumpus-Jack-Emmerichs-1978) and [more recently](https://blog.codinghorror.com/the-history-of-wumpus/).

_Hunt the Wumpus_' interface is strictly text-based, and your options each turn are limited to moving to an adjacent cave or firing an arrow.  If you'd like a map of the caves, you're welcome to draw one out on paper.

Python's built-in [`cmd` module](https://docs.python.org/3.11/library/cmd.html) is tailor-made for creating text-based interfaces, making Python a natural choice for this project.  Invoking a child class of the module's `Cmd` class starts a loop in which the user can enter commands.  Methods on this class that start with `do_` create those commands, in this case `move`, `shoot`, `help`, and `quit`.  There are also lifecycle hooks; the post-command lifecycle hook proved useful in tracking the results of the player's actions each turn. 

Text-based interface aside, the cave network may be the most interesting aspect of _Hunt the Wumpus_.  Instead of being arranged in a grid, these cave rooms correspond to the 20 vertices on a dodecahedron (a 12-sided solid) and are connected by the dodecahedron's edges.  Despite this arrangement, [it is possible to "flatten" the graph without causing the edges between connecting nodes to cross](https://en.wikipedia.org/wiki/Hunt_the_Wumpus#/media/File:Hunt_the_Wumpus_map.svg).

Comparing the cave network's representation in the original BASIC code and the Python reimplementation illustrates crucial differences between the languages.  BASIC includes arrays but lacks associative arrays; Python has both arrays (lists) and associative arrays (dictionaries).

The original BASIC code represents the cave network as a 20-by-3 matrix.  The following listing reads the 60 integers in the `DATA` statements into this matrix with two nested `FOR` loops.  The rows (`J`) correspond to the individual caves (numbered 1-20), and the three values in each row indicate the caves to which that cave connects.  That is, the first row represents the caves connected to cave 1, the second row contains the caves connected to cave 2, and so on. 

```basic
60 REM- SET UP CAVE (DODECAHEDRAL NODE LIST)
70 DIM S(20, 3)
80 FOR J=1 TO 20
90 FOR K=1 TO 3
100 READ S(J,K)
110 NEXT K
120 NEXT J
130 DATA 2,5,8,1,3,10,2,4,12,3,5,14,1,4,6
140 DATA 5,7,15,6,8,17,1,7,9,8,10,18,2,9,11
150 DATA 10,12,19,3,11,13,12,14,20,4,13,15,6,14,16
160 DATA 15,17,20,7,16,18,9,17,19,11,18,20,13,16,19
```

[Graphs are naturally represented as dictionaries in Python](https://www.python.org/doc/essays/graphs/).  In this case, the individual key-value pairs relate caves 1-20 to three-value tuples reflecting the connecting caves.  The values of this dictionary are tuples because [Python's typing system allows us to explicitly specify how many elements tuples contain](https://docs.python.org/3/library/typing.html#annotating-tuples).  Otherwise, frozensets might have been a more natural choice; the order-preserving property of tuples isn't necessary here.  Both data structures are immutable, which helps avoid accidental changes to the cave network.

```python
network = dict[int, tuple[int, int int]] = {
    1: (2, 5, 8),
    2: (1, 3, 10),
    3: (2, 4, 12),
    # some rows omitted
    20: (13, 16, 19),
}
```

The practical differences between these representations are minor, though I find the Python representation more readable.  Sampling a particular row of the two-dimensional array used in the BASIC code yields the same values as indexing into the dictionary used in the Python reimplementation.  However, the Python representation makes clear which three caves are connected to each cave, whereas determining that relationship from the BASIC code's DATA statements requires careful counting.  

Implentation details aside, the actual gameplay is unexciting.  The suspense of the original game likely stemmed from a new player's lack of understanding of the rules and the cave network.  With the understanding that comes from rewriting the code, it is possible to win virtually every time.  Good, trivial strategies include 1) carefully checking each cave until the Wumpus' location is known and then shooting it with an arrow and 2) covering the cave network with arrow shots, hoping to hit the Wumpus.  The second strategy is less certain than the first because the Wumpus moves when an arrow is fired, and thus the player can run out of arrows before hitting the Wumpus.  Still, four well-aimed shots can cover most of the cave network, leaving one arrow if an on-foot search is needed. 

The game could be made more interesting by adding a turn limit or making the Wumpus less passive.  A turn limit could be justified by giving the hunter a light that goes out after some number of turns.  The Wumpus could actively hunt the player.  Either would make the game less predictable and more suspenseful, even for players that already understand the caves and their denizens.  

Personally, though, I feel sorry for the Wumpus, so I'd like to see a version that doesn't end with its death.  The original game says that no one has ever seen the Wumpus.  What if the goal of the game were to photograph the Wumpus with a programmable camera drone, instead of shooting it with an arrow?
