Title: A Python hunts the Wumpus
Date: 2024-11-12
Category: reimplementation

I recently rewrote the game _Hunt the Wumpus_ in Python.  In _Hunt the Wumpus_, you play a hunter who seeks to kill a creature called the Wumpus with your arrows.  You move from room to room within a cave system, looking for traces of the Wumpus and avoiding hazards.  You win if you shoot the Wumpus with an arrow; you lose if you fall victim to the Wumpus or one of the hazards.

_Hunt the Wumpus_ comes to us from the early 1970s, an era when games were typed in from magazines or sent in the mail on cassettes.  The interface is strictly text-based, and your options each turn are limited to moving to an adjacent cave or firing an arrow.  If you'd like a map of the caves, you're welcome to draw one out on paper.

The code is reprinted in a book called _What to Do After You Hit Return: A Computer Games Book from People's Computer Company_ (1977).  The code is written in Hewlett-Packard 2000F BASIC.  The game has been reimplemented and improved upon repeatedly, both [soon after its initial publication](https://archive.org/details/Super-Wumpus-Jack-Emmerichs-1978) and [more recently](https://blog.codinghorror.com/the-history-of-wumpus/).

Python is a good choice for this reimplementation project because the `cmd` module in Python's standard library is tailor-made for creating text-based interfaces like the one that _Hunt the Wumpus_ uses.  On a personal level, I wrote Python code in a previous role and wanted to spend more time with the language.

Text-based interface aside, the cave network may be the most interesting aspect of _Hunt the Wumpus_.  Instead of being arranged in a grid, these cave rooms correspond to the 20 vertices on a dodecahedron (a 12-sided solid) and are connected by the dodecahedron's edges.  Despite this arrangement, it is possible to "flatten" the graph without causing the edges between connecting nodes to cross.  

Comparing the cave network's representation in the original BASIC code and the Python reimplementation illustrates crucial differences between the languages.  BASIC includes arrays but lacks associative arrays; Python has both arrays (lists) and associative arrays (dictionaries).

The original BASIC code represents the cave network as a 20-by-3 matrix.  The following listing reads the 60 integers in the `DATA` statements into this matrix with two nested `FOR` loops.  The rows (`J`) correspond to the individual caves (numbered 1-20), and the three values in each row indicate the caves to which that cave connects.  That is, the first row represents the caves connected to cave 1, the second row contains the caves connected to cave 2, and so on. 

```basic
60 REM- SET UP CAVE (DODECAHEDRAL NODE LIST)
70 DIM S(20, 3)
80 FOR J=1 TO 20
90 FOR K=1 TO 3
100 READ S(J,K)
110 NEXT K
120 NEXT J
130 DATA 2,5,8,1,3,10,2,4,12,3,5,14,1,4,6
140 DATA 5,7,15,6,8,17,1,7,9,8,10,18,2,9,11
150 DATA 10,12,19,3,11,13,12,14,20,4,13,15,6,14,16
160 DATA 15,17,20,7,16,18,9,17,19,11,18,20,13,16,19
```

[Graphs are naturally represented as dictionaries in Python](https://www.python.org/doc/essays/graphs/).  In this case, the individual key-value pairs relate caves 1-20 to three-value tuples reflecting the connecting caves.  The values of this dictionary are tuples because [Python's typing system allows us to explicitly specify that the tuples have three elements apiece](https://docs.python.org/3/library/typing.html#annotating-tuples).  Otherwise, frozensets might have been a more natural choice; the order-preserving property of tuples isn't necessary here.

```python
network = Mapping[int, tuple[int, int int]] = {
    1: (2, 5, 8),
    2: (1, 3, 10),
    3: (2, 4, 12),
    # some rows omitted 
    20: (13, 16, 19),
}
```

As might be expected given the nearly 30-year age difference between BASIC and Python, I find the Python representation more readable.  The Python representation makes clear which three caves are connected to each cave, whereas determining that relationship from the BASIC code requires careful counting. 

The BASIC and Python listings also illustrate the adjacency-matrix and adjacency-list graph representations, respectively.  The practical differences are minor for this application because sampling a particular row of the two-dimensional array used in the BASIC code yields the same values as indexing into the dictionary used in the Python reimplementation.

Possible improvements
Less violent setup -- you're trying to photograph the Wumpus with a camera drone, instead of killing it with arrows 
Add a turn limit
Make the Wumpus try to catch the player 
Automap
