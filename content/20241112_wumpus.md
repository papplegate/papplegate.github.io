Title: A Python hunts the Wumpus
Date: 2024-11-12
Category: reimplementation

I recently rewrote the game _Hunt the Wumpus_ in Python.  In _Hunt the Wumpus_, you play a hunter who seeks to kill a creature called the Wumpus with your arrows.  You move from room to room within a cave system, looking for traces of the Wumpus and avoiding hazards.  You win if you shoot the Wumpus with an arrow; you lose if you fall victim to the Wumpus or one of the hazards. 

_Hunt the Wumpus_ comes to us from the early 1970s, an era when games were typed in from magazines or sent in the mail on cassettes.  The interface is strictly text-based, and your options each turn are limited to moving to an adjacent cave or firing an arrow.  If you'd like a map of the caves, you're welcome to draw one out on paper. 

The code is reprinted in a book called _What to Do After You Hit Return: A Computer Games Book from People's Computer Company_ (1977).  

Python is a good choice for this project because the `cmd` module in Python's standard library is tailor-made for creating text-based interfaces like the one that _Hunt the Wumpus_ uses.  On a personal level, I wrote Python code in a previous role and liked it.  I wanted to spend some more time with the language by implementing something nontrivial.  

The cave rooms in _Hunt the Wumpus_ are not arranged in a grid -- instead, they correspond to the vertices on a dodecahedron (a 20-sided solid) and connected by the dodecahedron's edges.  Despite this arrangement, it is possible to "flatten" the graph without causing the edges between connecting nodes to cross. 

The original BASIC code represents the cave network as an adjacency matrix.  The following listing converts the 60 integers in the `DATA` statements into a 20x3 matrix.  The rows (`J`) correspond to the individual caves (numbered 1-20), and the three values in each row indicate the caves to which that cave connects. 

```basic
60 REM- SET UP CAVE (DODECAHEDRAL NODE LIST)
70 DIM S(20, 3)
80 FOR J=1 TO 20
90 FOR K=1 TO 3
100 READ S(J,K)
110 NEXT K
120 NEXT J
130 DATA 2,5,8,1,3,10,2,4,12,3,5,14,1,4,6
140 DATA 5,7,15,6,8,17,1,7,9,8,10,18,2,9,11
150 DATA 10,12,19,3,11,13,12,14,20,4,13,15,6,14,16
160 DATA 15,17,20,7,16,18,9,17,19,11,18,20,13,16,19
```

Modern languages like Python offer maps -- relationships between keys and values -- that allow an adjacency-list representation.  In this case, the individual key-value pairs relate caves 1-20 to three-value tuples reflecting the connecting caves.

```python
{
    1: (2, 5, 8),
    2: (1, 3, 10),
    3: (2, 4, 12),
    4: (3, 5, 14),
    5: (4, 1, 6),
    6: (5, 7, 15),
    7: (6, 8, 17),
    8: (1, 7, 9),
    9: (8, 10, 18),
    10: (2, 9, 11),
    11: (10, 12, 19),
    12: (3, 11, 13),
    13: (12, 14, 20),
    14: (4, 13, 15),
    15: (6, 14, 16),
    16: (15, 17, 20),
    17: (7, 16, 18),
    18: (9, 17, 19),
    19: (11, 18, 20),
    20: (13, 16, 19),
}
```



This arrangement is naturally represented as an adjacency list, which relates each node to its connected nodes.  

The original BASIC code represents this network as an undifferentiated array of 60 integers.  In this array, the first three values represent the caves connected to cave 1; the fourth, fifth, and sixth values are the caves connected to cave 2; and so on.   

In modern languages, an associative array relating nodes to their connected nodes is a natural representation of this structure.   

network as dictionary of int: tuple[int, int, int]
use the cmd module
    - prompt
    - commands
    - help
    - hooks, particularly postcmd
recursion
mypy, black

Possible improvements
Less violent setup -- you're trying to photograph the Wumpus with a camera drone, instead of killing it with arrows 
Add a turn limit
Make the Wumpus try to catch the player 
Automap
